package com.arvindand.mcp.maven.service;

import com.arvindand.mcp.maven.model.MavenCoordinate;
import com.arvindand.mcp.maven.model.security.SecurityAssessment;
import com.arvindand.mcp.maven.model.security.VulnerabilityInfo;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClient;

/**
 * Service for vulnerability scanning via OSV.dev API.
 *
 * <p>Design decisions:
 *
 * <ul>
 *   <li>Caffeine cache with 6-hour TTL (vulns change less frequently than versions)
 *   <li>Virtual threads for bulk parallel scanning
 *   <li>Circuit breaker to handle OSV outages gracefully
 *   <li>Rate limiter respecting OSV's guidelines
 *   <li>Semaphore for bounded parallelism
 * </ul>
 *
 * @author Arvind Menon
 * @since 2.0.0
 */
@Service
public class VulnerabilityService {

  private static final Logger logger = LoggerFactory.getLogger(VulnerabilityService.class);
  private static final String OSV_API_URL = "https://api.osv.dev/v1/query";
  private static final int MAX_CONCURRENT_OSV_REQUESTS = 5;
  private static final int CACHE_MAX_SIZE = 5000;
  private static final int CACHE_HOURS = 6;

  private final RestClient restClient;
  private final Cache<String, SecurityAssessment> cache;
  private final Semaphore osvSemaphore = new Semaphore(MAX_CONCURRENT_OSV_REQUESTS);

  public VulnerabilityService(RestClient.Builder restClientBuilder) {
    this.restClient = restClientBuilder.baseUrl(OSV_API_URL).build();

    this.cache =
        Caffeine.newBuilder()
            .maximumSize(CACHE_MAX_SIZE)
            .expireAfterWrite(Duration.ofHours(CACHE_HOURS))
            .recordStats()
            .build();
  }

  /**
   * Check vulnerabilities for a single dependency.
   *
   * @param coordinate Maven coordinate including version
   * @return security assessment for the dependency
   */
  @CircuitBreaker(name = "osv", fallbackMethod = "scanFallback")
  @RateLimiter(name = "osv")
  public SecurityAssessment scan(MavenCoordinate coordinate) {
    if (coordinate.version() == null || coordinate.version().isBlank()) {
      return SecurityAssessment.unknown("Version required for vulnerability scanning");
    }

    String cacheKey = buildCacheKey(coordinate);
    SecurityAssessment cached = cache.getIfPresent(cacheKey);
    if (cached != null) {
      return cached;
    }

    SecurityAssessment result = fetchFromOsv(coordinate);
    cache.put(cacheKey, result);
    return result;
  }

  /**
   * Bulk scan with bounded parallelism using virtual threads.
   *
   * @param coordinates list of Maven coordinates with versions
   * @return map of coordinate string to security assessment
   */
  public Map<String, SecurityAssessment> scanBulk(List<MavenCoordinate> coordinates) {
    if (coordinates == null || coordinates.isEmpty()) {
      return Map.of();
    }

    Map<String, SecurityAssessment> results = new ConcurrentHashMap<>();
    List<MavenCoordinate> cacheMisses = new ArrayList<>();

    // Check cache hits first
    for (var coord : coordinates) {
      addCacheHitOrMiss(coord, results, cacheMisses);
    }

    if (cacheMisses.isEmpty()) {
      return results;
    }

    // Fetch cache misses with bounded parallelism
    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
      var futures =
          cacheMisses.stream()
              .map(
                  coord ->
                      CompletableFuture.supplyAsync(
                          () -> {
                            try {
                              osvSemaphore.acquire();
                              try {
                                var assessment = fetchFromOsv(coord);
                                cache.put(buildCacheKey(coord), assessment);
                                return Map.entry(coord.toCoordinateString(), assessment);
                              } finally {
                                osvSemaphore.release();
                              }
                            } catch (InterruptedException _) {
                              Thread.currentThread().interrupt();
                              return Map.entry(
                                  coord.toCoordinateString(),
                                  SecurityAssessment.unknown("Interrupted"));
                            }
                          },
                          executor))
              .toList();

      for (var future : futures) {
        try {
          var entry = future.get(30, TimeUnit.SECONDS);
          results.put(entry.getKey(), entry.getValue());
        } catch (InterruptedException _) {
          Thread.currentThread().interrupt();
          logger.warn("OSV bulk request interrupted");
          break;
        } catch (java.util.concurrent.TimeoutException
            | java.util.concurrent.ExecutionException
            | RuntimeException e) {
          logger.warn("OSV bulk request failed: {}", e.getMessage());
        }
      }
    }

    return results;
  }

  private String buildCacheKey(MavenCoordinate coord) {
    return coord.groupId() + ":" + coord.artifactId() + ":" + coord.version();
  }

  private SecurityAssessment fetchFromOsv(MavenCoordinate coord) {
    try {
      var request =
          new OsvRequest(
              new OsvPackage("Maven", coord.groupId() + ":" + coord.artifactId()), coord.version());

      OsvResponse response =
          restClient
              .post()
              .contentType(MediaType.APPLICATION_JSON)
              .body(request)
              .retrieve()
              .body(OsvResponse.class);

      if (response == null || response.vulns() == null || response.vulns().isEmpty()) {
        return SecurityAssessment.clean();
      }

      List<VulnerabilityInfo> vulns =
          response.vulns().stream()
              .map(this::mapOsvVulnerability)
              .filter(Objects::nonNull)
              .toList();

      String lowestFixed = findLowestFixedVersion(response.vulns());

      return SecurityAssessment.fromVulnerabilities(vulns, lowestFixed);

    } catch (RuntimeException e) {
      logger.warn("OSV query failed for {}: {}", coord.toCoordinateString(), e.getMessage());
      return SecurityAssessment.unknown("OSV query failed: " + e.getMessage());
    }
  }

  private VulnerabilityInfo mapOsvVulnerability(OsvVulnerability osv) {
    if (osv == null || osv.id() == null) {
      return null;
    }

    // Extract CVSS score
    double cvss = 0.0;
    if (osv.severity() != null) {
      cvss =
          osv.severity().stream()
              .filter(s -> "CVSS_V3".equals(s.type()) && s.score() != null)
              .findFirst()
              .map(s -> parseDouble(s.score()))
              .orElse(0.0);
    }

    // Find fixed version
    String fixedVersion = null;
    if (osv.affected() != null) {
      fixedVersion =
          osv.affected().stream()
              .filter(a -> a.ranges() != null)
              .flatMap(a -> a.ranges().stream())
              .filter(r -> r.events() != null)
              .flatMap(r -> r.events().stream())
              .filter(e -> e.fixed() != null)
              .map(OsvEvent::fixed)
              .findFirst()
              .orElse(null);
    }

    // Get reference URL
    String reference = null;
    if (osv.references() != null && !osv.references().isEmpty()) {
      reference = osv.references().getFirst().url();
    }

    String summary = osv.summary() != null ? osv.summary() : osv.details();

    return new VulnerabilityInfo(
        osv.id(),
        VulnerabilityInfo.Severity.fromCvss(cvss),
        cvss,
        summary,
        fixedVersion,
        reference);
  }

  private double parseDouble(String value) {
    try {
      return Double.parseDouble(value);
    } catch (NumberFormatException _) {
      return 0.0;
    }
  }

  private String findLowestFixedVersion(List<OsvVulnerability> vulns) {
    // Find the highest "fixed" version that covers all vulnerabilities
    return vulns.stream()
        .filter(v -> v.affected() != null)
        .flatMap(v -> v.affected().stream())
        .filter(a -> a.ranges() != null)
        .flatMap(a -> a.ranges().stream())
        .filter(r -> r.events() != null)
        .flatMap(r -> r.events().stream())
        .filter(e -> e.fixed() != null)
        .map(OsvEvent::fixed)
        .max(Comparator.naturalOrder())
        .orElse(null);
  }

  @SuppressWarnings("unused") // Used via @CircuitBreaker fallbackMethod
  private SecurityAssessment scanFallback(MavenCoordinate coordinate, Throwable t) {
    if (logger.isWarnEnabled()) {
      logger.warn(
          "OSV circuit breaker open for {}: {}", coordinate.toCoordinateString(), t.getMessage());
    }
    return SecurityAssessment.unknown("Security check unavailable - OSV service unreachable");
  }

  private void addCacheHitOrMiss(
      MavenCoordinate coord,
      Map<String, SecurityAssessment> results,
      List<MavenCoordinate> cacheMisses) {
    if (coord.version() == null || coord.version().isBlank()) {
      results.put(coord.toCoordinateString(), SecurityAssessment.unknown("Version required"));
      return;
    }

    String key = buildCacheKey(coord);
    SecurityAssessment cached = cache.getIfPresent(key);
    if (cached != null) {
      results.put(coord.toCoordinateString(), cached);
      return;
    }

    cacheMisses.add(coord);
  }

  // OSV API DTOs - public for native image reflection hints
  public record OsvRequest(@JsonProperty("package") OsvPackage pkg, String version) {}

  public record OsvPackage(String ecosystem, String name) {}

  @JsonIgnoreProperties(ignoreUnknown = true)
  public record OsvResponse(List<OsvVulnerability> vulns) {}

  @JsonIgnoreProperties(ignoreUnknown = true)
  public record OsvVulnerability(
      String id,
      String summary,
      String details,
      List<OsvSeverity> severity,
      List<OsvAffected> affected,
      List<OsvReference> references) {}

  @JsonIgnoreProperties(ignoreUnknown = true)
  public record OsvSeverity(String type, String score) {}

  @JsonIgnoreProperties(ignoreUnknown = true)
  public record OsvAffected(List<OsvRange> ranges) {}

  @JsonIgnoreProperties(ignoreUnknown = true)
  public record OsvRange(String type, List<OsvEvent> events) {}

  @JsonIgnoreProperties(ignoreUnknown = true)
  public record OsvEvent(String introduced, String fixed) {}

  @JsonIgnoreProperties(ignoreUnknown = true)
  public record OsvReference(String type, String url) {}
}
